---
title: Diffie-Hellman key exchange in Haskell
author: Leo Zhang
tags: haskell, cryptography, diffie-hellman key exchange
---

## Key exchange problem
In the [previous](https://github.com/zhangchiqing/blog/blob/master/posts/2018-03-08-symmetric-key-encryption.md) [blog posts](https://github.com/zhangchiqing/blog/blob/master/posts/2018-03-10-symmetric-key-encryption-aes-ctr-mode.md), we talked about Symmetric key encryption, and how to encrypt message with a secret key, so that even if someone else got the ciphertext, they can't decrypt it, only who  holds the secret key is able to decrypt the ciphertext.

But the question is: How to exchange a shared secret key between two parties if the messaging channel is not secure?

Sharing the secret key securely between two communication parties is as important as sharing the message.

If Alice naively sends the secret key to Bob, then a middleman (Eve) will be able to receive it and decrypt the ciphertext.

```
Alice --- make --> secret key ----------- share to ------------------------> secret key
   |                   |                     |                                   |
   |                   |                   steal                                 |
   |                   |                     |                                   |
   |                   |                     v                                   |
   |                   |                 secret key                              |
   |                   |                     |                                   |
   |                   |                     v                                   |
   |                   |                  decrypt ----> message ---> Eve         |
   |                   |                     ^                                   |
   |                   |                     |                                   |
   |                   |                   cipher                                |
   |                   |                     ^                                   |
   |                   |                     |                                   |
   |                   v                   steal                                 v
   |                encrypt                  |                                decrypt
   ---- message ------------> cipher ---- share to -----> cipher  ---------------------> message --> Bob

```

## Diffie-Hellman key exchange
Diffie-Hellman key exchange allows two parties to exchange some public information and run some computation to compute the same shared key.

Let's say Alice and Bob want to make a shared key, but the communication channel has been listened by hacker Eve. Then Alice and Bob can use the following steps to make a shared key using Diffie-Hellman key exchange method.

1) Alice sends two primes to Bob (P and G)
P has to be very big, G can be small. Both P and G can be public, it doesn't matter even if Eve retrieved it.
2) Alice generates a private random number (A)
`A` has to be an integer that is smaller than `P - 2`
3) Bob generates a private random number (B)
`B` has to be an integer that is smaller than `P - 2` too.
4) Alice computes `G^A mod P` and sends it to Bob
This number can be public
5) Bob computes `G^B mod P` and sends it to Alice
This number can be public too.
6) Alice computes `(G^B mod P) ^ A mod P`
7) Bob computes `(G^A mod P) ^ B mod P`

Since
```
(G^B mod P) ^ A mod P
  == G^(B * A) mod P
  == G^(A * B) mod P
  == (G^A mod P) ^ B mod P
```

Therefore in Step 6 and 7, Alice and Bob will get the same number after the computation. That number is the shared key.

## Haskell implementation
The library `cryptonite` provides Diffie-Hellman implementation under the namespace `Crypto.PubKey.DH`.

The `getShared` function is what we need.

```haskell
getShared :: Params -> PrivateNumber -> PublicNumber -> SharedKey
```

It takes a few types as input that are new to us.

The type [Params](https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-DH.html#t:Params) is the two primes `P` and `G`, generated in step 1.

The `PrivateNumber` is the private number generated by Alice in step 2.

The `PublicNumber` is the `G^B mod P` that received from B publicly in step 5

With all the above parameters, `getShared` will compute the SharedKey in step 6. And the `SharedKey` is what we want.

Let's go through each parameter and find out how to make them.

### Generates `P` and `G`
How to create a `Params` type value?

If we look up the document and search for a function that returns `Params`, we will find [`generateParams`](https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-DH.html#v:generateParams).

```haskell
generateParams :: MonadRandom m => Int	-> Integer -> m Params
```

Looks like it can generate `Params` with numbers. Let's experiment it in GHCi:

```
stack ghci src/DiffieHellman.hs

ghci> import Crypto.PubKey.DH
ghci> generateParams 256 3
Params {params_p = 110563099972437044823860819206549886826858051041947933265285586398516130315983, params_g = 3, params_bits = 256}
```

Cool, it returns a `Params` type that contains the public `P` and `G`.

Observe the type signature of `generateParams`. The `MonadRandom m` in the type signature is a typeclass that presents a computation that will return a different result each time. Since [`IO` is an instance of `MonadRandom`](https://hackage.haskell.org/package/MonadRandom-0.1.3/docs/Control-Monad-Random-Class.html#control.i:MonadRandom), GHCi is able to run `m Params` as `IO Params`.

### Generates `PrivateNumber`
The second parameter is `PrivateNumber`. We need a function that returns a type `PrivateNumber`. Yes there is one: [`generatePrivate`](https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-DH.html#v:generatePrivate)

```haskell
generatePrivate :: MonadRandom m => Params -> m PrivateNumber
```

It takes `Params` as input. That's because `Params` contains the information that is required for computing the private number: The private number has to be smaller than `P - 2`.

Let's try it in GHCi:
```
stack ghci src/DiffieHellman.hs

ghci> import Crypto.PubKey.DH
ghci> pg <- generateParams 256 3
ghci> generatePrivate pg
PrivateNumber 35797929284417927696905144527611704505718008561138038330654412659656974132056
```

Great! We got the `PrivateNumber`, and it's a very big random number.

### Compute the Public Number
As step 3, we need the public number. Again, we look for a function in the document that returns `PublicNumber`. And we found `calculatePublic`.

```haskell
calculatePublic :: Params -> PrivateNumber -> PublicNumber
```

Note that the public number is not Alice's public number, it's Bob's public number. In step 5, Bob computes `G^B mod P` and this is a Public Number to be sent to Alice.

So for Bob to make a public number, he also needs a private number.

To keep this tutorial simple, we will not implement two parties communication process, but simplify assume the public numbers are shared within a function.

Let's try it in GHCi
```
stack ghci src/DiffieHellman.hs

ghci> import Crypto.PubKey.DH
ghci> pg <- generateParams 256 3
ghci> alicePrivateNumber <- generatePrivate pg
ghci> bobPrivateNumber <- generatePrivate pg
ghci> let bobPubNumber = calculatePublic pg bobPrivateNumber
ghci> bobPubNumber
PublicNumber 92924039299970721733980469270788249559726299091074393940146569304066521598156
```

OK, the `bobPubNumber` is the Public Number computed by bob that will be sent to Alice.


Note `bobPrivateNumber <- generatePrivate pg` we used `<-`, but we used `let` in `let bobPubNumber = calculatePublic pg bobPrivateNumber`.

That's because `generatePrivate` returns `m Params` which is a computation that has side effect. Whereas, `calculatePublic` returns `PublicKey` which is a pure computation doesn't have side effect, so we use `let` to assign the return value to variables `bobPubNumber`.

In a pure functional language like Haskell, we need to distinguish pure function that has no side effect and a non-pure function that has side effect.

### Compute the shared key
Alright, with the `Params`, `PrivateNumber` and `PublicNumber`, we now can use `getShared` to compute the shared key.

```haskell
stack ghci src/DiffieHellman.hs

ghci> import Crypto.PubKey.DH
ghci> pg <- generateParams 256 3
ghci> alicePrivateNumber <- generatePrivate pg
ghci> bobPrivateNumber <- generatePrivate pg
ghci> let bobPubNumber = calculatePublic pg bobPrivateNumber
ghci> getShared pg alicePrivateNumber bobPubNumber
SharedKey <scrubbed-bytes>
```

## Put all together to compute the shared key
If we put together all the pieces and get a shared key, we can make this function:


```haskell
{-# LANGUAGE OverloadedStrings #-}

module DiffieHellman where

import Crypto.PubKey.DH
import Crypto.Cipher.Types (IV(..), ecbEncrypt, ecbDecrypt, ctrCombine, makeIV, blockSize, cipherInit)
import Crypto.Cipher.AES (AES256(..))
import Data.ByteString (ByteString, pack)
import Data.ByteArray (unpack)
import SymmetricCTR

publicPG :: IO Params
publicPG = generateParams bits generator
  where
    bits = 256
    generator = 2

testDH :: IO SharedKey
testDH =
  print "generate publicly sharable p and g, p is 256 bits prime, g is a small prime (2)"
  pg <- publicPG
  print pg

  print "alice generates a private random number"
  alicePrivateNumber <- generatePrivate pg

  print "alice calculates a public number ( G^A mod P)"
  let alicePublicNumber = calculatePublic pg alicePrivateNumber
  print (alicePrivateNumber, alicePublicNumber)

  print "bob generates a private random number"
  bobPrivateNumber <- generatePrivate pg

  print "bob calculates a public number ( G^B mod P)"
  let bobPublicNumber = calculatePublic pg bobPrivateNumber
  print (bobPrivateNumber, bobPublicNumber)

  print "alice calcluates the shared key"
  let aliceSharedKey = getShared pg alicePrivateNumber bobPublicNumber

  print "bob calcluates the shared key"
  let bobSharedKey = getShared pg bobPrivateNumber alicePublicNumber

  print "alice and bob should get the same key without exposing their private numbers"
  print $ aliceSharedKey == bobSharedKey

  return aliceSharedKey
```

```
ghci> testDH
"generate publicly sharable p and g, p is 256 bits prime, g is a small prime (2)"
Params {params_p = 102235116241958143041621221722110579775465457242719792676615639464481007751419, params_g = 2, params_bits = 256}
"alice generates a private random number"
"alice calculates a public number ( G^A mod P)"
(PrivateNumber 51097811525530460212626279077167543464255131703571541436211623349360385977129,PublicNumber 81780395563219518988108856779736635386349999398496425239467455986206217615429)
"bob generates a private random number"
"bob calculates a public number ( G^B mod P)"
(PrivateNumber 48188062420236399908687447608830965846741610990182161959670829612127461152702,PublicNumber 11869146767895109003068511860201991468632330126477395058068707014642110620070)
"alice calcluates the shared key"
"bob calcluates the shared key"
"alice and bob should get the same key without exposing their private numbers"
True
SharedKey <scrubbed-bytes>
```

## Use the SharedKey to encrypt messages
Great, now we have the shared key. How can we use that to send an encrypted message and let the other party decrypt it?

Recall in the previous blog post, we introduced symmetric key encryption, and [how to encrypt a message using AES256 algorithm in CTR mode](https://github.com/zhangchiqing/blog/blob/master/posts/2018-03-10-symmetric-key-encryption-aes-ctr-mode.md). Those functions can be used here to encrypt and decrypt the message.

### import module
We've already learned how to import a module by namespace. To import a module defined within the project, we can simply find the declared namespace, and import it.

The namespace that has all the functions we created for AES encryption is `Symmetric`, we can just `import SymmetricCTR` to import all those functions.

### Convert secret key
Our existing encryption function `encryptMsgCTR` takes a `ByteString` type as a secret key. But the shared key which we got at the end of the Diffie-Hellman key exchange is a type `SharedKey`. They don't fit. How can we turn a `SharedKey` into `ByteString`?

Seems like there is no existing function with the signature `SharedKey -> ByteString)`. That's OK. Let's try to find what can `SharedKey` be converted to.

[The documentation shows](https://hackage.haskell.org/package/cryptonite-0.25/docs/Crypto-PubKey-DH.html#t:SharedKey) `SharedKey` is an instance of type class of `ByteArrayAccess`.

[In the documentation of `ByteArrayAccess`](https://hackage.haskell.org/package/memory-0.14.14/docs/Data-ByteArray.html#t:ByteArrayAccess), we can find some functions that can take `ByteArrayAccess` type and convert to some other type.

There is this function [`unpack`](https://hackage.haskell.org/package/memory-0.14.14/docs/Data-ByteArray.html#v:unpack) that can process `ByteArrayAccess` type.

```haskell
unpack :: ByteArrayAccess a => a -> [Word8]
```

We've seen `[Word8]` type before in [the previous blog post](https://github.com/zhangchiqing/blog/blob/master/posts/2018-03-10-symmetric-key-encryption-aes-ctr-mode.md#print-iv-typeclass), it's a list of bytes. Alright, is there any function in `Data.ByteString` namespace that can take `[Word8]` can convert it into `ByteString`.

Yes! that's [`pack`](https://hackage.haskell.org/package/bytestring-0.10.8.2/docs/Data-ByteString.html#v:pack)

So we can use `[Word8]` as a middle step to convert a `SharedKey` into a `ByteString`.

```
                     Data.ByteArray.unpack                       Data.ByteString.pack
SharedKey ------------------------------------> [Word8] ---------------------------------> ByteString
```

Continue with the previous GHCi session, we can experiment the `unpack` and `pack` function like this:

```
ghci> sharedKey <- testDH

ghci> sharedKey
SharedKey <scrubbed-bytes>

ghci> import Data.ByteArray (unpack)

ghci> unpack sharedKey
[32,88,15,143,176,0,192,67,183,210,229,70,188,19,216,160,74,125,199,192,197,185,93,239,53,66,186,255,148,34,75,237]

ghci> import Data.ByteString (pack)

ghci> pack (unpack sharedKey)
" X\SI\143\176\NUL\192C\183\210\229F\188\DC3\216\160J}\199\192\197\185]\239\&5B\186\255\148\"K\237"
```

Cool we got the shared key in `ByteString` type. Now we can implement a `makeSharedKey` function by combining these two functions:

```haskell
import Data.ByteString (ByteString, pack)
import Data.ByteArray (unpack)

makeSharedKey :: SharedKey -> ByteString
makeSharedKey sharedKey = pack (unpack sharedKey)
```

### Function composition
Function composition is a very important concept in functional programming. It allows us to create reusable functions to deal with problems by combining small functions that deal with subproblems.

How is how function composition works:

If there is a function `f :: a -> b` that takes type `a` and returns type `b`, and another function `g :: b -> c` that takes `b` and return `c`. Then `g (f a)` will return `c` because, `(f a)` returns `b`, and `g b` returns `c`.

`g (f a)` can also be written as `(g . f) a` or `g . f a`.

`.` is the function composition operator to blue `g` and `f` together. `g . f` returns a new function that will take `a` and return `c`.

Let's use the `pack` and `unpack` function as an example, and verify what we learned in GHCi
```
stack ghci src/DiffieHellman.hs

ghci> :t unpack
unpack
  :: memory-0.14.11:Data.ByteArray.Types.ByteArrayAccess a =>
     a -> [GHC.Word.Word8]

ghci> :t pack
pack :: [GHC.Word.Word8] -> ByteString

ghci> :t pack . unpack
pack . unpack
  :: memory-0.14.11:Data.ByteArray.Types.ByteArrayAccess a =>
     a -> ByteString
```

Combining `pack` and `unpack` using `.` as `pack . unpack` will return a new function that will return a generic `ByteArrayAccess` type and return a `ByteString` type

Let's try to refactor the `makeSharedKey` function with function composition:

```haskell
makeSharedKey :: SharedKey -> ByteString
makeSharedKey sharedKey = pack . unpack sharedKey
```

Since `sharedKey` appears on both ends, we can further refactor it into point-free style

```haskell
makeSharedKey :: SharedKey -> ByteString
makeSharedKey = pack . unpack
```

## Encrypting and decrypting with the shared key
OK. With everything we have so far, we can now encrypt and decrypt a message with the shared key. Since we've talked about how to create an `IV` in the [previous blog post](https://github.com/zhangchiqing/blog/blob/master/posts/2018-03-10-symmetric-key-encryption-aes-ctr-mode.md), here we will reuse the `makeIVFromInt` function from that module.

Here is a simple function that makes a shared key and creates a secret key with that, encrypts and decrypt a message with that secret key.

```haskell
testEncryptWithSharedKey = do
  sharedKey <- testDH
  -- ByteString
  let Right sKey = makeSecretKey $ makeSharedKey sharedKey

  let iv = makeIVFromInt 100
  print $ encryptMsgCTR sKey iv "this is a message"
  print $ decryptMsgCTR sKey iv $ encryptMsgCTR sKey iv "this is a message encrypted by a shared key"
```

Let's test it in GHCi:
```
stack ghci src/DiffieHellman.hs

ghci> testEncryptWithSharedKey
"generate publicly sharable p and g, p is 256 bits prime, g is a small prime (2)"
Params {params_p = 112166503010650279695103137639650672371132535070011177427303695537162291854859, params_g = 2, params_bits = 256}
"alice generates a private random number"
"alice calculates a public number ( G^A mod P)"
(PrivateNumber 108609815107456503971688130984315987655344290327141230360250614851771625672106,PublicNumber 62616374324182248213764355212597080341561066763157983279853247863112086473927)
"bob generates a private random number"
"bob calculates a public number ( G^B mod P)"
(PrivateNumber 8651712645606133278463294752531127641854570728549349373823194124183177344910,PublicNumber 110429105760107326412344089926902449468458516715975844240862572070577196878291)
"alice calcluates the shared key"
"bob calcluates the shared key"
"alice and bob should get the same key without exposing their private numbers"
True
"a\136\246\195\179{]\STXvE\ETB|i\189\230\v\t"
"this is a message encrypted by a shared key"
```

The last two lines printed the encrypted message and the decrypted message which is the same as the original message.

## Summary
In this blog post, we introduced the key exchange problem and how Diffie-Hellman key exchange solves it. We used the library `cryptonite` to create a shared key between two parties, encrypted and decrypted a message with that shared key.

Along the way, we also introduced how to look up the Haskell document to find the function we need, and how to use function composition in Haskell which is a very important concept for functional programming.
